/******************************************************************
 * generate-home-page.ts â€” Home Page Content Generation
 * ---------------------------------------------------------------
 * PURPOSE:
 * Generates home page content for a specific location using
 * an OpenAI Assistant. Triggered by boolean flip on client_websites.
 * 
 * PATTERN:
 * 1. Database trigger fires on generate_home_page = true
 * 2. Trigger calls this edge function via net.http_post
 * 3. Function fetches client, location, business info data
 * 4. Calls OpenAI Assistant with payload
 * 5. Inserts generated content into client_home_page
 * 6. Resets trigger to false
 * 
 * NOTE: Services section links are NOT generated by AI.
 * Frontend queries client_policy_categories and builds routes.
 ******************************************************************/

const OPENAI_ASSISTANT_ID = 'asst_sdbwiYhgzrVhvpgEZK0l3C8H';
const OPENAI_BASE_URL = 'https://api.openai.com/v1';

// ============================================================
// SUPABASE HELPER
// ============================================================
async function sb(path: string, options: RequestInit = {}) {
  const url = Deno.env.get('SUPABASE_URL')!;
  const key = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
  console.log(`[Supabase] ${options.method || 'GET'} ${path}`);
  return fetch(`${url}/rest/v1/${path}`, {
    ...options,
    headers: {
      'apikey': key,
      'Authorization': `Bearer ${key}`,
      'Content-Type': 'application/json',
      'Prefer': options.method === 'POST' ? 'return=representation' : undefined,
      ...options.headers ?? {}
    } as Record<string, string>
  });
}

// ============================================================
// OPENAI ASSISTANT RUNNER
// ============================================================
async function runAssistant(apiKey: string, assistantId: string, payload: any) {
  const headers = {
    Authorization: `Bearer ${apiKey}`,
    'Content-Type': 'application/json',
    'OpenAI-Beta': 'assistants=v2'
  };

  // Create thread
  console.log('[OpenAI] Creating thread...');
  const threadRes = await fetch(`${OPENAI_BASE_URL}/threads`, {
    method: 'POST',
    headers,
    body: '{}'
  });
  if (!threadRes.ok) throw new Error(`Thread creation failed: ${threadRes.status}`);
  const { id: threadId } = await threadRes.json();
  console.log(`[OpenAI] Thread created: ${threadId}`);

  // Add message with payload
  console.log('[OpenAI] Adding message...');
  const msgRes = await fetch(`${OPENAI_BASE_URL}/threads/${threadId}/messages`, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      role: 'user',
      content: [{ type: 'text', text: JSON.stringify(payload) }]
    })
  });
  if (!msgRes.ok) throw new Error(`Message creation failed: ${msgRes.status}`);

  // Start run
  console.log('[OpenAI] Starting run...');
  const runRes = await fetch(`${OPENAI_BASE_URL}/threads/${threadId}/runs`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ assistant_id: assistantId })
  });
  if (!runRes.ok) throw new Error(`Run creation failed: ${runRes.status}`);
  const { id: runId } = await runRes.json();

  // Poll for completion (max 4 minutes)
  console.log('[OpenAI] Polling for completion...');
  for (let i = 0; i < 120; i++) {
    const statusRes = await fetch(`${OPENAI_BASE_URL}/threads/${threadId}/runs/${runId}`, { headers });
    const status = await statusRes.json();
    
    if (status.status === 'completed') {
      console.log('[OpenAI] Run completed');
      const msgsRes = await fetch(`${OPENAI_BASE_URL}/threads/${threadId}/messages`, { headers });
      const msgs = await msgsRes.json();
      const assistantMsg = msgs.data.find((m: any) => m.role === 'assistant');
      
      if (!assistantMsg?.content?.[0]?.text?.value) {
        throw new Error('No assistant response found');
      }
      
      // Clean markdown code blocks if present
      let raw = assistantMsg.content[0].text.value.trim();
      raw = raw.replace(/^```(?:json|javascript|js)?\s*/gim, '');
      raw = raw.replace(/```\s*$/gim, '');
      
      return JSON.parse(raw.trim());
    }
    
    if (['failed', 'cancelled', 'expired'].includes(status.status)) {
      throw new Error(`Assistant run ${status.status}: ${status.last_error?.message || 'Unknown error'}`);
    }
    
    await new Promise(r => setTimeout(r, 2000));
  }
  throw new Error('Assistant timeout after 4 minutes');
}

// ============================================================
// DATA INTERFACES
// ============================================================
interface LocationData {
  id: string;
  city: string;
  state: string;
  address: string;
  phone: string | null;
  zip: string;
  location_slug: string;
  service_areas: string[];
  timezone: string;
}

interface ClientData {
  agency_name: string;
  canonical_url: string;
  phone: string;
  number_of_locations: string;
}

interface BusinessInfo {
  founding_year: number | null;
  years_in_business_text: string | null;
  regional_descriptor: string | null;
  slogan: string | null;
  tagline: string | null;
}

interface PolicyCategory {
  name: string;
  slug: string;
  description: string | null;
}

interface WebsiteData {
  business_hours: Record<string, any>;
}

// ============================================================
// DATA FETCHERS
// ============================================================
async function getLocationData(locationId: string): Promise<LocationData | null> {
  const response = await sb(`client_locations?id=eq.${locationId}&select=id,city,state,address_line_1,phone,zip,location_slug,service_areas,timezone`);
  if (!response.ok) return null;
  
  const data = await response.json();
  if (!data || data.length === 0) return null;
  
  const loc = data[0];
  return {
    id: loc.id,
    city: loc.city,
    state: loc.state,
    address: loc.address_line_1,
    phone: loc.phone,
    zip: loc.zip,
    location_slug: loc.location_slug,
    service_areas: loc.service_areas || [],
    timezone: loc.timezone || 'America/Chicago'
  };
}

async function getClientData(clientId: string): Promise<ClientData | null> {
  const response = await sb(`clients?id=eq.${clientId}&select=agency_name,website_url,phone,number_of_locations`);
  if (!response.ok) return null;
  
  const data = await response.json();
  if (!data || data.length === 0) return null;
  
  const client = data[0];
  return {
    agency_name: client.agency_name,
    canonical_url: client.website_url,
    phone: client.phone,
    number_of_locations: client.number_of_locations || '1'
  };
}

async function getBusinessInfo(clientId: string): Promise<BusinessInfo | null> {
  const response = await sb(`client_business_info?client_id=eq.${clientId}&select=founding_year,years_in_business_text,regional_descriptor,slogan,tagline`);
  if (!response.ok) return null;
  
  const data = await response.json();
  if (!data || data.length === 0) return null;
  
  return data[0];
}

async function getPolicyCategories(clientId: string): Promise<PolicyCategory[]> {
  const response = await sb(`client_policy_categories?client_id=eq.${clientId}&published=eq.true&select=display_name,slug,description&order=sort_order`);
  if (!response.ok) return [];
  
  const data = await response.json();
  return (data || []).map((cat: any) => ({
    name: cat.display_name,
    slug: cat.slug,
    description: cat.description
  }));
}

async function getWebsiteData(clientId: string, locationId: string): Promise<WebsiteData | null> {
  const response = await sb(`client_websites?client_id=eq.${clientId}&location_id=eq.${locationId}&select=business_hours`);
  if (!response.ok) return null;
  
  const data = await response.json();
  if (!data || data.length === 0) return null;
  
  return {
    business_hours: data[0].business_hours || {}
  };
}

async function checkExistingHomePage(clientId: string, locationId: string): Promise<boolean> {
  const response = await sb(`client_home_page?client_id=eq.${clientId}&location_id=eq.${locationId}&select=id`);
  if (!response.ok) return false;
  
  const data = await response.json();
  return data && data.length > 0;
}

// ============================================================
// LD-JSON BUILDER
// ============================================================
function buildHomePageLdJson(
  clientData: ClientData,
  locationData: LocationData,
  businessInfo: BusinessInfo
): any {
  // Build areaServed from service_areas
  const areaServed = (locationData.service_areas || []).map((city: string) => ({
    '@type': 'City',
    'name': city,
    'containedInPlace': {
      '@type': 'State',
      'name': locationData.state
    }
  }));
  
  // Add primary city if not in list
  if (!areaServed.find((a: any) => a.name === locationData.city)) {
    areaServed.unshift({
      '@type': 'City',
      'name': locationData.city,
      'containedInPlace': {
        '@type': 'State',
        'name': locationData.state
      }
    });
  }
  
  return {
    '@context': 'https://schema.org',
    '@type': 'WebPage',
    'name': `${clientData.agency_name} | Insurance in ${locationData.city}, ${locationData.state}`,
    'description': `Trusted insurance agency in ${locationData.city}, ${locationData.state}. Auto, home, business, and life insurance.`,
    'url': clientData.canonical_url,
    'mainEntity': {
      '@type': 'InsuranceAgency',
      'name': clientData.agency_name,
      'url': clientData.canonical_url,
      'telephone': locationData.phone || clientData.phone,
      'foundingDate': businessInfo.founding_year?.toString(),
      'slogan': businessInfo.slogan || businessInfo.tagline,
      'address': {
        '@type': 'PostalAddress',
        'streetAddress': locationData.address,
        'addressLocality': locationData.city,
        'addressRegion': locationData.state,
        'postalCode': locationData.zip,
        'addressCountry': 'US'
      },
      'areaServed': areaServed
    }
  };
}

// ============================================================
// RESET TRIGGER
// ============================================================
async function resetTrigger(clientId: string, locationId: string): Promise<void> {
  console.log(`[Trigger] Resetting generate_home_page for client ${clientId}, location ${locationId}`);
  await sb(`client_websites?client_id=eq.${clientId}&location_id=eq.${locationId}`, {
    method: 'PATCH',
    body: JSON.stringify({ generate_home_page: false })
  });
}

// ============================================================
// MAIN HANDLER
// ============================================================
Deno.serve(async (req) => {
  console.log('=== GENERATE HOME PAGE STARTED ===');
  
  if (req.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 });
  }
  
  let client_id: string | undefined;
  let location_id: string | undefined;
  
  try {
    const body = await req.json();
    client_id = body.client_id;
    location_id = body.location_id;
    const generate_home_page = body.generate_home_page;
    
    // Validate trigger
    if (!client_id || !location_id || !generate_home_page) {
      console.log('[Skip] Missing required fields or trigger is false');
      return new Response('Skip - conditions not met', { status: 200 });
    }
    
    console.log(`[Main] Processing client: ${client_id}, location: ${location_id}`);
    
    // 1. Check if home page already exists
    const exists = await checkExistingHomePage(client_id, location_id);
    if (exists) {
      console.log('[Skip] Home page already exists for this location');
      await resetTrigger(client_id, location_id);
      return new Response('Home page already exists', { status: 200 });
    }
    
    // 2. Fetch location data
    const locationData = await getLocationData(location_id);
    if (!locationData) {
      console.error('[Error] Location not found');
      await resetTrigger(client_id, location_id);
      return new Response('Location not found', { status: 404 });
    }
    console.log(`[Data] Location: ${locationData.city}, ${locationData.state}`);
    
    // 3. Fetch client data
    const clientData = await getClientData(client_id);
    if (!clientData) {
      console.error('[Error] Client not found');
      await resetTrigger(client_id, location_id);
      return new Response('Client not found', { status: 404 });
    }
    console.log(`[Data] Client: ${clientData.agency_name}`);
    
    // 4. Fetch business info (REQUIRED)
    const businessInfo = await getBusinessInfo(client_id);
    if (!businessInfo?.founding_year || !businessInfo?.years_in_business_text || !businessInfo?.regional_descriptor) {
      console.error('[Error] Business info incomplete - should have been blocked by trigger');
      await resetTrigger(client_id, location_id);
      return new Response('Business info incomplete', { status: 400 });
    }
    console.log(`[Data] Business: Founded ${businessInfo.founding_year}, ${businessInfo.years_in_business_text}`);
    
    // 5. Fetch policy categories (for AI context)
    const policyCategories = await getPolicyCategories(client_id);
    console.log(`[Data] Policy categories: ${policyCategories.length} found`);
    
    // 6. Fetch website data (business hours)
    const websiteData = await getWebsiteData(client_id, location_id);
    
    // 7. Build AI payload
    const aiPayload = {
      // Location data
      location_city: locationData.city,
      location_state: locationData.state,
      service_areas: locationData.service_areas,
      address: locationData.address,
      zip: locationData.zip,
      phone: locationData.phone || clientData.phone,
      timezone: locationData.timezone,
      
      // Client data
      agency_name: clientData.agency_name,
      
      // Business info
      founding_year: businessInfo.founding_year,
      years_in_business: businessInfo.years_in_business_text,
      regional_descriptor: businessInfo.regional_descriptor,
      slogan: businessInfo.slogan,
      tagline: businessInfo.tagline,
      
      // Business hours
      business_hours: websiteData?.business_hours || {},
      
      // Policy categories (for context only - AI does not generate links)
      policy_categories: policyCategories
    };
    
    console.log('[AI] Calling OpenAI Assistant...');
    
    // 8. Call OpenAI Assistant
    const apiKey = Deno.env.get('OPENAI_API_KEY');
    if (!apiKey) {
      console.error('[Error] OPENAI_API_KEY not set');
      await resetTrigger(client_id, location_id);
      return new Response('API key not configured', { status: 500 });
    }
    
    const aiContent = await runAssistant(apiKey, OPENAI_ASSISTANT_ID, aiPayload);
    console.log(`[AI] Response received. Keys: ${Object.keys(aiContent).join(', ')}`);
    
    // 9. Build LD-JSON (system-built, not AI)
    const ldJson = buildHomePageLdJson(clientData, locationData, businessInfo);
    
    // 10. Prepare insert data
    const insertData = {
      client_id,
      location_id,
      hero_section: aiContent.hero_section || null,
      intro_section: aiContent.intro_section || null,
      services_section: aiContent.services_section || null,
      cta_section: aiContent.cta_section || null,
      common_questions_section: aiContent.common_questions_section || null,
      meta_title: aiContent.meta_title || null,
      meta_description: aiContent.meta_description || null,
      ldjson: ldJson,
      updated_at: new Date().toISOString()
    };
    
    // 11. Insert into database
    console.log('[DB] Inserting home page content...');
    const insertResponse = await sb('client_home_page', {
      method: 'POST',
      body: JSON.stringify(insertData)
    });
    
    if (!insertResponse.ok) {
      const errorText = await insertResponse.text();
      console.error(`[Error] Insert failed: ${errorText}`);
      await resetTrigger(client_id, location_id);
      return new Response(`Insert failed: ${errorText}`, { status: 500 });
    }
    
    console.log(`[Success] Home page generated for ${locationData.city}, ${locationData.state}`);
    
    // 12. Reset trigger
    await resetTrigger(client_id, location_id);
    
    return new Response(`Home page generated for ${locationData.city}`, { status: 200 });
    
  } catch (error) {
    console.error(`[Error] ${(error as Error).message}`);
    
    // Always reset trigger on error to prevent infinite retries
    if (client_id && location_id) {
      await resetTrigger(client_id, location_id);
    }
    
    return new Response(`Error: ${(error as Error).message}`, { status: 500 });
  }
});
